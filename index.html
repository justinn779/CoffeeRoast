<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>ÁÉòË±ÜË®àÁï´ËàáÁ¥ÄÈåÑ</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3Eü´ò%3C/text%3E%3C/svg%3E">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" integrity="sha512-qZvrmS2ekKPF2mSznTQsxqPgnpkI4DNTlrdUmTzrDgektczlKNRRhy5X5AAOnx5S09ydFYWWNSfcEqDTTHgtNA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background-color: #f8f9fa; color: #343a40; }

        .controls-wrapper { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
        .controls-row { display: flex; align-items: center; flex-wrap: wrap; gap: 15px; }

        .controls-row button {
            border: none; padding: 10px 16px; border-radius: 6px; font-size: 14px;
            font-weight: 500; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .controls-row button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .controls-row button:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }

        #startStop { background-color: #28a745; color: white; }
        #startStop.running { background-color: #ffc107; color: #212529; }
        #resetBtn { background-color: #dc3545; color: white; }
        #openModalBtn { background-color: #17a2b8; color: white; }
        #exportPngBtn, #exportPdfBtn { background-color: #6c757d; color: white; }
        #exportPngBtn:disabled, #exportPdfBtn:disabled { background-color: #adb5bd; cursor: not-allowed; }

        #timer { font-size: 28px; color: #e63946; font-weight: bold; }
        #targetTemp { font-size: 22px; color: #1d3557; }

        #timelineContainer { max-height: 400px; overflow-y: auto; overflow-x: auto; width: 100%; }
        #timelineTable {
            border-collapse: collapse; margin-bottom: 20px; font-size: 12px;
            width: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        #timelineTable th, #timelineTable td {
            border: 1px solid #dee2e6; padding: 1px; text-align: center; white-space: nowrap;
        }
        #timelineTable th {
            background-color: #f8f9fa; position: sticky; left: 0; z-index: 1; font-weight: normal; padding: 4px 2px;
        }
        #timelineTable select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: auto;
            min-width: 60px;
            padding: 4px;
            border: none;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 13px;
            background-color: #fff;
            background-image: none;
            text-align: center;
        }
        .current-time-col { background-color: #fffacd !important; font-weight: bold; }

        .ror-val { color: #2a9d8f; font-weight: bold; }
        .plan-ror-val { color: #e76f51; font-weight: bold; }

        #modalPlan {
            position: fixed; z-index: 10; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5); display: none; padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe; margin: auto; padding: 25px; border: 1px solid #888;
            width: 90%; max-width: 900px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-radius: 8px; max-height: 85vh; overflow-y: auto;
        }
        .modal-table-container { overflow-x: auto; }
        .modal-table-container table { width: 100%; border-collapse: collapse; margin-bottom: 15px; }
        .modal-table-container th, .modal-table-container td { border: 1px solid #ccc; padding: 8px; text-align: center; white-space: nowrap; }
        .modal-table-container select {
             -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: auto; min-width: 80px; padding: 8px; border: 1px solid #ddd; box-sizing: border-box; font-size: 14px;
            background-image: none;
            text-align: center;
        }
        .time-select-group select { width: 60px; min-width: 50px; }

        .close-btn { color: #aaa; float: right; font-size: 30px; font-weight: bold; }
        .close-btn:hover, .close-btn:focus { color: #000; text-decoration: none; cursor: pointer; }

        #curveContainer { position: relative; width: 100%; max-width: 850px; height: 450px; margin-top: 20px; }
        #roastCurveCanvas {
            position: absolute; top: 10px; left: 0; width: 100%; height: 440px;
            border: 1px solid #ced4da; background-color: #fff; border-radius: 4px;
        }
    </style>
</head>
<body>

<div class="controls-wrapper">
    <div class="controls-row">
        <button id="startStop">ÈñãÂßã</button>
        <span id="timer">00:00</span>
        <span id="targetTemp">ÁõÆÊ®ôÊ∫´Â∫¶: 150.0</span>
    </div>
    <div class="controls-row">
        <button id="openModalBtn">ÈóúÈçµÈªûË®àÁï´</button>
        <button id="exportPngBtn">ÂåØÂá∫ÂúñÁâá</button>
        <button id="exportPdfBtn">ÂåØÂá∫ PDF</button>
        <button id="resetBtn">ÈáçË®≠</button>
    </div>
</div>

<div id="exportable-content">
    <div id="timelineContainer">
        <table id="timelineTable"></table>
    </div>
    <div id="curveContainer">
        <canvas id="roastCurveCanvas"></canvas>
    </div>
</div>

<div id="modalPlan" class="modal">
    <div class="modal-content">
        <span class="close-btn">&times;</span>
        <h3>Ë®≠ÂÆöÁÉòÁÑôÈóúÈçµÈªûË®àÁï´</h3>
        <button id="autoPlanBtn" style="margin-bottom: 15px; background-color: #28a745; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer;">Ëá™ÂãïË®àÁï´‰∏¶Â•óÁî®</button>
        <div class="modal-table-container">
            <table id="keyPointsTable"></table>
        </div>
    </div>
</div>

<script>
    // --- ÂÖ®ÂüüÂ∏∏Êï∏ËàáËÆäÊï∏ ---
    const TIME_STEP_SECONDS = 30;
    const MAX_TIME_MINUTES = 12;
    const NUM_POINTS = (MAX_TIME_MINUTES * 60 / TIME_STEP_SECONDS) + 1;
    const MIN_TEMP = 100.0;
    const MAX_TEMP = 230.0;
    const TEMP_STEP = 0.5;

    const MIN_POWER = 0.0;
    const MAX_POWER = 2.0;
    const POWER_STEP = 0.1;

    let seconds = 0;
    let running = false;
    let timerInterval = null;
    let targetInterval = null;
    let lastUpdateIndex = -1;

    let roastData = [];
    let actualTAT = { planIndex: 3 };

    let PLAN_KEY_POINTS = [
        { name: 'ÂÖ•Ë±ÜÊ∫´', time: 0, temp: 150.0, ror: 0, power: 0.4 },
        { name: 'ÂõûÊ∫´Èªû (Ë®àÁï´)', time: 90, temp: 110.0, ror: 0, power: 0.8 },
        { name: 'Ê¢ÖÁ¥çÊúü', time: 360, temp: 165.0, ror: 0, power: 1.0 },
        { name: '‰∏ÄÁàÜÈñãÂßã', time: 480, temp: 195.0, ror: 0, power: 0.3 },
        { name: '‰∏ÄÁàÜÁµêÊùü', time: 570, temp: 210.0, ror: 0, power: 0.5 },
        { name: '‰∏ãË±Ü', time: 600, temp: 215.0, ror: 0, power: 0.0 }
    ];

    const startStopBtn = document.getElementById('startStop');
    const resetBtn = document.getElementById('resetBtn');
    const openModalBtn = document.getElementById('openModalBtn');
    const exportPngBtn = document.getElementById('exportPngBtn');
    const exportPdfBtn = document.getElementById('exportPdfBtn');
    const modalPlan = document.getElementById('modalPlan');
    const closeBtn = document.querySelector('.close-btn');
    const autoPlanBtn = document.getElementById('autoPlanBtn');
    const keyPointsTable = document.getElementById('keyPointsTable');
    const timerEl = document.getElementById('timer');
    const targetTempEl = document.getElementById('targetTemp');
    const timelineTable = document.getElementById('timelineTable');

    function roundToNearestStep(value, step) {
        return Math.round(value / step) * step;
    }

    function createTempOptions(min, max, step, defaultValue) {
        let optionsHTML = '';
        const fixedDefault = parseFloat(defaultValue).toFixed(1);
        for (let t = min * 10; t <= max * 10; t += step * 10) {
            const temp = (t / 10).toFixed(1);
            const selected = (fixedDefault === temp) ? 'selected' : '';
            optionsHTML += `<option value="${temp}" ${selected}>${temp}</option>`;
        }
        return optionsHTML;
    }

    function createNumericOptions(min, max, step, defaultValue) {
        let optionsHTML = '';
        const fixedDefault = parseFloat(defaultValue).toFixed(1);
        const minInt = Math.round(min / step);
        const maxInt = Math.round(max / step);
        for (let i = minInt; i <= maxInt; i++) {
            const val = (i * step);
            const fixedVal = val.toFixed(1);
            const selected = (fixedDefault === fixedVal) ? 'selected' : '';
            optionsHTML += `<option value="${fixedVal}" ${selected}>${fixedVal}</option>`;
        }
        return optionsHTML;
    }

    function createMinuteSecondOptions(totalSeconds) {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        let minOptionsHTML = '';
        for (let m = 0; m <= MAX_TIME_MINUTES; m++) {
            minOptionsHTML += `<option value="${m}" ${m === minutes ? 'selected' : ''}>${String(m).padStart(2, '0')}</option>`;
        }
        let secOptionsHTML = '';
        for (let s = 0; s < 60; s++) {
            secOptionsHTML += `<option value="${s}" ${s === seconds ? 'selected' : ''}>${String(s).padStart(2, '0')}</option>`;
        }
        return { minOptions: minOptionsHTML, secOptions: secOptionsHTML };
    }

    function getInterpolatedPlanTemp(timeSeconds, points) {
        const uniquePoints = [...new Map(points.map(item => [item['time'], item])).values()].sort((a, b) => a.time - b.time);
        if (uniquePoints.length === 0) return 0;
        if (timeSeconds <= uniquePoints[0].time) return uniquePoints[0].temp;
        if (timeSeconds >= uniquePoints[uniquePoints.length - 1].time) return uniquePoints[uniquePoints.length - 1].temp;
        for (let i = 0; i < uniquePoints.length - 1; i++) {
            const p1 = uniquePoints[i], p2 = uniquePoints[i + 1];
            if (timeSeconds >= p1.time && timeSeconds <= p2.time) {
                if (timeSeconds === p2.time) return p2.temp;
                const timeRange = p2.time - p1.time;
                if (timeRange === 0) return p1.temp;
                const tempRange = p2.temp - p1.temp;
                const ratio = (timeSeconds - p1.time) / timeRange;
                return p1.temp + tempRange * ratio;
            }
        }
        return uniquePoints[uniquePoints.length - 1].temp;
    }

    function getPlanPowerForTime(timeSeconds, points) {
        const uniquePoints = [...new Map(points.map(item => [item['time'], item])).values()].sort((a, b) => a.time - b.time);
        if (uniquePoints.length === 0) return 0.0;
        for (let i = uniquePoints.length - 1; i >= 0; i--) {
            if (timeSeconds >= uniquePoints[i].time) return uniquePoints[i].power;
        }
        return uniquePoints[0].power;
    }

    function handleModalTimeInput(index) {
        const minEl = document.getElementById(`kp_min_${index}`);
        const secEl = document.getElementById(`kp_sec_${index}`);
        if (!minEl || !secEl) return;
        let newTime = parseInt(minEl.value) * 60 + parseInt(secEl.value);
        PLAN_KEY_POINTS[index].time = Math.min(newTime, MAX_TIME_MINUTES * 60);
        updateModalRoRDisplays();
    }

    function handleModalInput(index, key) {
        let inputEl = document.getElementById(`kp_${key}_${index}`);
        if (!inputEl) return;
        PLAN_KEY_POINTS[index][key] = parseFloat(inputEl.value);
        updateModalRoRDisplays();
    }

    function initializeModalTable() {
        let tableHTML = `<thead><tr><th>ÂçÄÈñìÂêçÁ®±</th><th>ÊôÇÈñì (ÂàÜ:Áßí)</th><th>Ê∫´Â∫¶</th><th>RoR (¬∞C/min)</th><th>ÁÅ´Âäõ</th></tr></thead><tbody>`;
        PLAN_KEY_POINTS.forEach((point, index) => {
            const { minOptions, secOptions } = createMinuteSecondOptions(point.time);
            const timeInput = `<span class="time-select-group"><select id="kp_min_${index}" onchange="handleModalTimeInput(${index})">${minOptions}</select>:<select id="kp_sec_${index}" onchange="handleModalTimeInput(${index})">${secOptions}</select></span>`;
            const tempOptions = createTempOptions(MIN_TEMP, MAX_TEMP, TEMP_STEP, point.temp);
            const powerOptions = createNumericOptions(MIN_POWER, MAX_POWER, POWER_STEP, point.power);
            tableHTML += `<tr id="kp_row_${index}"><td>${point.name}</td><td>${timeInput}</td><td><select id="kp_temp_${index}" onchange="handleModalInput(${index}, 'temp')">${tempOptions}</select></td><td id="kp_ror_${index}">0.0</td><td><select id="kp_power_${index}" onchange="handleModalInput(${index}, 'power')">${powerOptions}</select></td></tr>`;
        });
        keyPointsTable.innerHTML = tableHTML + `</tbody>`;
    }

    function updateModalRoRDisplays() {
        for (let i = 0; i < PLAN_KEY_POINTS.length; i++) {
            const rorEl = document.getElementById(`kp_ror_${i}`);
            if (!rorEl) continue;
            if (i === 0) {
                rorEl.textContent = '0.0';
            } else {
                const current = PLAN_KEY_POINTS[i], prev = PLAN_KEY_POINTS[i - 1];
                if (current.time <= prev.time) {
                    rorEl.textContent = 'Err:ÊôÇÈñìÂÄíÈÄÄ';
                    continue;
                }
                const timeDiff = current.time - prev.time, tempDiff = current.temp - prev.temp;
                rorEl.textContent = ((tempDiff / timeDiff) * 60).toFixed(1);
            }
        }
    }

    function applyKeyPointsToRoastData() {
        const dropPoint = PLAN_KEY_POINTS.find(p => p.name === '‰∏ãË±Ü');
        const dropTime = dropPoint ? dropPoint.time : Infinity;
        for (let i = 0; i < NUM_POINTS; i++) {
            const totalSeconds = i * TIME_STEP_SECONDS;
            const newPlanTemp = getInterpolatedPlanTemp(totalSeconds, PLAN_KEY_POINTS);
            const finalPlanTemp = roundToNearestStep(newPlanTemp, 0.5);
            const newPlanPower = getPlanPowerForTime(totalSeconds, PLAN_KEY_POINTS);
            const finalPlanPower = roundToNearestStep(newPlanPower, POWER_STEP);

            if (totalSeconds > dropTime) {
                roastData[i].planTemp = roastData[i].actualTemp = roastData[i].planPower = roastData[i].actualPower = 0;
                ['pt', 'at', 'pp', 'ap'].forEach(prefix => {
                    let parent = document.getElementById(`${prefix}_${i}`)?.parentNode;
                    if (parent) parent.innerHTML = '-';
                });
                document.getElementById(`pror_${i}`).textContent = '-';
                document.getElementById(`aror_${i}`).textContent = '-';
            } else {
                roastData[i].planTemp = roastData[i].actualTemp = parseFloat(finalPlanTemp.toFixed(1));
                roastData[i].planPower = parseFloat(finalPlanPower.toFixed(1));
                ['pt', 'at'].forEach(prefix => {
                    const select = document.getElementById(`${prefix}_${i}`);
                    if (select) select.value = roastData[i].planTemp.toFixed(1);
                });
                ['pp', 'ap'].forEach(prefix => {
                    const select = document.getElementById(`${prefix}_${i}`);
                    if (select) select.value = roastData[i].planPower.toFixed(1);
                });
            }
        }
        const planTATPoint = PLAN_KEY_POINTS.find(p => p.name.includes('ÂõûÊ∫´Èªû'));
        if (planTATPoint) actualTAT.planIndex = Math.round(planTATPoint.time / TIME_STEP_SECONDS);
        updateAllPlanRoR();
        updateActualRoRChain(0);
        updateTargetTempDisplay();
        generateImage();
        closePlanModal();
    }

    function openPlanModal() {
        initializeModalTable();
        updateModalRoRDisplays();
        modalPlan.style.display = 'block';
    }

    function closePlanModal() {
        modalPlan.style.display = 'none';
    }

    function initializeRoastDataAndTable() {
        document.querySelectorAll('.current-time-col').forEach(el => el.classList.remove('current-time-col'));
        roastData = [];

        const headers = ['ÊôÇÈñì', 'Ë®àÁï´Ê∫´Â∫¶', 'Ë®àÁï´ RoR', 'Ë®àÁï´ÁÅ´Âäõ', 'ÂØ¶ÈöõÊ∫´Â∫¶', 'ÂØ¶Èöõ RoR', 'ÂØ¶ÈöõÁÅ´Âäõ'];
        let tableHTML = '<tbody>';
        headers.forEach((header, index) => {
            tableHTML += `<tr id="row_${index}"><th>${header}</th></tr>`;
        });
        tableHTML += '</tbody>';
        timelineTable.innerHTML = tableHTML;

        for (let i = 0; i < NUM_POINTS; i++) {
            const totalSeconds = i * TIME_STEP_SECONDS;
            const timeLabel = `${String(Math.floor(totalSeconds / 60)).padStart(2, '0')}:${String(totalSeconds % 60).padStart(2, '0')}`;
            const initialPlanTemp = roundToNearestStep(getInterpolatedPlanTemp(totalSeconds, PLAN_KEY_POINTS), 0.5);
            const initialPlanPower = getPlanPowerForTime(totalSeconds, PLAN_KEY_POINTS);
            roastData.push({
                time: totalSeconds,
                planTemp: parseFloat(initialPlanTemp.toFixed(1)),
                planRoR: 0,
                planPower: parseFloat(initialPlanPower.toFixed(1)),
                actualTemp: parseFloat(initialPlanTemp.toFixed(1)),
                actualPower: parseFloat(initialPlanPower.toFixed(1)),
            });

            document.getElementById('row_0').innerHTML += `<td id="time_${i}">${timeLabel}</td>`;
            document.getElementById('row_1').innerHTML += `<td><select id="pt_${i}" onchange="handlePlanInput(${i}, 'pt')">${createTempOptions(MIN_TEMP, MAX_TEMP, TEMP_STEP, roastData[i].planTemp)}</select></td>`;
            document.getElementById('row_2').innerHTML += `<td id="pror_${i}" class="plan-ror-val">0.0</td>`;
            document.getElementById('row_3').innerHTML += `<td><select id="pp_${i}" onchange="handlePlanInput(${i}, 'pp')">${createNumericOptions(MIN_POWER, MAX_POWER, POWER_STEP, roastData[i].planPower)}</select></td>`;
            document.getElementById('row_4').innerHTML += `<td><select id="at_${i}" onchange="handleActualInput(${i})">${createTempOptions(MIN_TEMP, MAX_TEMP, TEMP_STEP, roastData[i].actualTemp)}</select></td>`;
            document.getElementById('row_5').innerHTML += `<td id="aror_${i}" class="ror-val">0.0</td>`;
            document.getElementById('row_6').innerHTML += `<td><select id="ap_${i}" onchange="handleActualPowerInput(${i})">${createNumericOptions(MIN_POWER, MAX_POWER, POWER_STEP, roastData[i].actualPower)}</select></td>`;
        }
        updateAllPlanRoR();
        updateActualRoRChain(0);
        updateTargetTempDisplay();
    }


    function calculateRoR(currentIndex, tempKey) {
        if (currentIndex === 0) return 0;
        const T_now = parseFloat(roastData[currentIndex][tempKey]);
        const T_prev = parseFloat(roastData[currentIndex - 1][tempKey]);
        if (T_now === 0 && T_prev > 0) return NaN; // Sudden drop to 0 is invalid
        if (tempKey === 'actualTemp' && (T_prev === 0.0 || T_prev === undefined)) return NaN;
        if (isNaN(T_now) || isNaN(T_prev)) return 0;
        return (T_now - T_prev) * 2;
    }

    function updateAllPlanRoR() {
        for (let i = 0; i < NUM_POINTS; i++) {
            const ror = calculateRoR(i, 'planTemp');
            const rorEl = document.getElementById(`pror_${i}`);
            if (rorEl) {
                rorEl.textContent = isNaN(ror) ? '--' : ror.toFixed(1);
                roastData[i].planRoR = ror;
            }
        }
    }

    function updateActualRoRChain(startIndex) {
        for (let i = startIndex; i < NUM_POINTS; i++) {
            const ror = calculateRoR(i, 'actualTemp');
            const rorEl = document.getElementById(`aror_${i}`);
            if (rorEl) rorEl.textContent = isNaN(ror) ? '--' : ror.toFixed(1);
        }
    }

    function handlePlanInput(index, key) {
        const selectEl = document.getElementById(key + '_' + index);
        if (!selectEl) return;
        const newValue = parseFloat(selectEl.value);
        const dataKey = (key === 'pt') ? 'planTemp' : 'planPower';
        roastData[index][dataKey] = newValue;
        if (dataKey === 'planTemp') {
            roastData[index].actualTemp = newValue;
            const atSelect = document.getElementById(`at_${index}`);
            if (atSelect) atSelect.value = newValue.toFixed(1);
            updateActualRoRChain(index);
            const planTATIndex = PLAN_KEY_POINTS.findIndex(p => p.name.includes('ÂõûÊ∫´Èªû'));
            if (index === actualTAT.planIndex && planTATIndex !== -1) PLAN_KEY_POINTS[planTATIndex].temp = newValue;
        } else {
            const planTATIndex = PLAN_KEY_POINTS.findIndex(p => p.name.includes('ÂõûÊ∫´Èªû'));
            if (index === actualTAT.planIndex && planTATIndex !== -1) PLAN_KEY_POINTS[planTATIndex].power = newValue;
        }
        updateAllPlanRoR();
        updateTargetTempDisplay();
        generateImage();
    }

    function handleActualInput(index) {
        const selectEl = document.getElementById(`at_${index}`);
        if (!selectEl) return;
        roastData[index].actualTemp = parseFloat(selectEl.value);
        updateActualRoRChain(index);
        generateImage();
    }

    function handleActualPowerInput(index) {
        const selectEl = document.getElementById(`ap_${index}`);
        if (!selectEl) return;
        roastData[index].actualPower = parseFloat(selectEl.value);
        generateImage();
    }

    function updateTargetTempDisplay() {
        const totalSeconds = seconds;
        let targetTemp = '--';
        for (let i = 0; i < NUM_POINTS - 1; i++) {
            if (totalSeconds >= roastData[i].time && totalSeconds <= roastData[i + 1].time) {
                targetTemp = roastData[lastUpdateIndex]?.planTemp || roastData[i].planTemp;
                break;
            }
        }
        targetTempEl.textContent = `ÁõÆÊ®ôÊ∫´Â∫¶: ${targetTemp === '--' ? '--' : parseFloat(targetTemp).toFixed(1)}`;
    }

    function updateTimer() {
        seconds += 0.1;
        const totalSeconds = Math.floor(seconds);
        timerEl.textContent = `${String(Math.floor(totalSeconds / 60)).padStart(2, '0')}:${String(totalSeconds % 60).padStart(2, '0')}`;
        const currentIndex = Math.min(Math.floor(totalSeconds / TIME_STEP_SECONDS), NUM_POINTS - 1);
        if (currentIndex !== lastUpdateIndex) {
            document.querySelectorAll('.current-time-col').forEach(el => el.classList.remove('current-time-col'));
            if (currentIndex < NUM_POINTS) {
                const col = document.getElementById(`time_${currentIndex}`);
                if(col) {
                    col.classList.add('current-time-col');
                    // Highlight all cells in the same column
                    for(let j=0; j<7; j++) {
                        const cell = document.getElementById(`row_${j}`).children[currentIndex + 1];
                        if(cell) cell.classList.add('current-time-col');
                    }
                    col.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                }
            }
            lastUpdateIndex = currentIndex;
            updateTargetTempDisplay();
        }
    }

    function generateImage() {
        const canvas = document.getElementById('roastCurveCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        const { width, height } = rect;
        const offsetX = 50, plotWidth = width - offsetX - 20, plotHeight = height - 50;
        const maxTime = MAX_TIME_MINUTES * 60, maxTemp = 250, minTemp = 75, tempRange = maxTemp - minTemp;
        const scaleX = plotWidth / maxTime, scaleY = plotHeight / tempRange;

        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height);
        ctx.font = '10px sans-serif'; ctx.fillStyle = '#333';
        ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;

        for (let temp = maxTemp; temp >= minTemp; temp -= 25) {
            const y = plotHeight - (temp - minTemp) * scaleY;
            ctx.beginPath(); ctx.moveTo(offsetX, y); ctx.lineTo(width - 10, y); ctx.stroke();
            ctx.textAlign = 'right'; ctx.fillText(`${temp}`, offsetX - 8, y + 3);
        }
        ctx.save();
        ctx.textAlign = 'center'; ctx.translate(15, plotHeight / 2); ctx.rotate(-Math.PI / 2);
        ctx.fillText('Ê∫´Â∫¶', 0, 0);
        ctx.restore();

        for (let t = 0; t <= maxTime; t += 60) {
            const x = t * scaleX + offsetX;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, plotHeight); ctx.stroke();
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            ctx.fillText(`${String(Math.floor(t / 60)).padStart(2, '0')}:${String(t % 60).padStart(2, '0')}`, x, plotHeight + 8);
        }
        ctx.textBaseline = 'alphabetic'; ctx.fillText('ÊôÇÈñì (ÂàÜ:Áßí)', offsetX + plotWidth / 2, height - 10);

        const planPoints = roastData.filter(d => d.planTemp > 0).map(d => ({ x: d.time * scaleX + offsetX, y: plotHeight - (d.planTemp - minTemp) * scaleY }));
        ctx.strokeStyle = 'rgba(255, 140, 0, 0.8)'; ctx.lineWidth = 2; ctx.beginPath();
        planPoints.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
        ctx.stroke();
        ctx.fillStyle = 'rgba(255, 140, 0, 0.8)';
        planPoints.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill(); });
        if (planPoints.length > 0) {
            ctx.fillStyle = '#00f'; ctx.beginPath(); ctx.arc(planPoints[0].x, planPoints[0].y, 4, 0, Math.PI * 2); ctx.fill();
        }

        const actualPoints = roastData.filter(d => d.actualTemp > 0).map(d => ({ x: d.time * scaleX + offsetX, y: plotHeight - (d.actualTemp - minTemp) * scaleY }));
        if (actualPoints.length > 0) {
            ctx.strokeStyle = 'rgba(0, 158, 115, 0.8)'; ctx.lineWidth = 2; ctx.beginPath();
            actualPoints.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 158, 115, 0.8)';
            actualPoints.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill(); });
        }

        ctx.font = '12px sans-serif'; ctx.textAlign = 'left';
        const legendX = width - 120;
        ctx.fillStyle = 'rgba(255, 140, 0, 0.8)'; ctx.fillRect(legendX, 10, 10, 10);
        ctx.fillStyle = '#333'; ctx.fillText('Ë®àÁï´Êõ≤Á∑ö', legendX + 15, 19);
        ctx.fillStyle = 'rgba(0, 158, 115, 0.8)'; ctx.fillRect(legendX, 30, 10, 10);
        ctx.fillStyle = '#333'; ctx.fillText('ÂØ¶ÈöõÊõ≤Á∑ö', legendX + 15, 39);
    }

    async function exportDocument(format) {
        const exportContent = document.getElementById('exportable-content');
        const timelineContainer = document.getElementById('timelineContainer');
        const table = document.getElementById('timelineTable');
        [exportPngBtn, exportPdfBtn].forEach(btn => btn.disabled = true);
        exportPngBtn.textContent = 'ÂåØÂá∫‰∏≠...';

        const originalContainerStyle = { maxHeight: timelineContainer.style.maxHeight, overflowY: timelineContainer.style.overflowY };
        const originalTableStyle = { width: table.style.width };

        try {
            // Temporarily remove constraints to capture the full table
            timelineContainer.style.maxHeight = 'none';
            timelineContainer.style.overflowY = 'visible';
            table.style.width = 'auto'; // Let table expand to its natural width
            await new Promise(resolve => setTimeout(resolve, 100)); // Wait for re-render

            const canvas = await html2canvas(exportContent, {
                scale: 2,
                useCORS: true,
                logging: false,
                onclone: (clonedDoc) => {
                    // This logic is now more reliable because the whole table is visible
                    clonedDoc.querySelectorAll('select').forEach(select => {
                        const text = document.createElement('span');
                        const originalSelect = document.getElementById(select.id);
                        if (originalSelect && originalSelect.selectedIndex > -1) {
                            text.textContent = originalSelect.options[originalSelect.selectedIndex].text;
                        }
                        select.parentNode.replaceChild(text, select);
                    });
                }
            });

            const imgData = canvas.toDataURL('image/png');
            const filename = `roast-profile-${new Date().toISOString().slice(0, 10)}`;

            if (format === 'PNG') {
                const link = document.createElement('a');
                link.download = `${filename}.png`;
                link.href = imgData;
                link.click();
            } else if (format === 'PDF') {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({ orientation: 'landscape', unit: 'px', format: [canvas.width, canvas.height] });
                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                pdf.save(`${filename}.pdf`);
            }
        } finally {
            // Restore original styles
            timelineContainer.style.maxHeight = originalContainerStyle.maxHeight;
            timelineContainer.style.overflowY = originalContainerStyle.overflowY;
            table.style.width = originalTableStyle.width;
            [exportPngBtn, exportPdfBtn].forEach(btn => btn.disabled = false);
            exportPngBtn.textContent = 'ÂåØÂá∫ÂúñÁâá';
        }
    }

    openModalBtn.addEventListener('click', openPlanModal);
    closeBtn.addEventListener('click', closePlanModal);
    autoPlanBtn.addEventListener('click', applyKeyPointsToRoastData);
    exportPngBtn.addEventListener('click', () => exportDocument('PNG'));
    exportPdfBtn.addEventListener('click', () => exportDocument('PDF'));
    window.addEventListener('click', (event) => {
        if (event.target === modalPlan) closePlanModal();
    });

    startStopBtn.addEventListener('click', () => {
        running = !running;
        startStopBtn.textContent = running ? 'ÂÅúÊ≠¢' : 'ÈñãÂßã';
        startStopBtn.classList.toggle('running', running);
        // Only disable plan inputs
        document.querySelectorAll('select[id^="pt_"], select[id^="pp_"]').forEach(s => s.disabled = running);
        if (running) {
            timerInterval = setInterval(updateTimer, 100);
            targetInterval = setInterval(() => { updateTargetTempDisplay(); generateImage(); }, 1000);
        } else {
            clearInterval(timerInterval);
            clearInterval(targetInterval);
            document.querySelectorAll('.current-time-col').forEach(el => el.classList.remove('current-time-col'));
        }
    });

    resetBtn.addEventListener('click', () => {
        if (confirm('ÊÇ®Á¢∫ÂÆöË¶ÅÈáçË®≠ÊâÄÊúâË≥áÊñôÂóéÔºüÊ≠§Êìç‰ΩúÁÑ°Ê≥ïÂæ©Âéü„ÄÇ')) {
            running = false;
            startStopBtn.textContent = 'ÈñãÂßã';
            startStopBtn.classList.remove('running');
            clearInterval(timerInterval);
            clearInterval(targetInterval);
            seconds = 0;
            timerEl.textContent = '00:00';
            lastUpdateIndex = -1;
            actualTAT.planIndex = 3;
            const planTATIndex = PLAN_KEY_POINTS.findIndex(p => p.name.includes('ÂõûÊ∫´Èªû'));
            if (planTATIndex !== -1) {
                PLAN_KEY_POINTS[planTATIndex].time = 90;
                PLAN_KEY_POINTS[planTATIndex].temp = 110.0;
            }
            initializeRoastDataAndTable();
            generateImage();
        }
    });

    initializeRoastDataAndTable();
    generateImage();
    window.addEventListener('resize', generateImage); // Áõ£ËÅΩË¶ñÁ™óÂ§ßÂ∞èËÆäÂåñ
</script>

</body>
</html>
